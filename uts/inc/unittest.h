#if !defined(UNITTEST_HPP_INCLUDED)
#define UNITTEST_HPP_INCLUDED

#include <iostream>
#include <string>
#include <vector>
#include <exception>

#include "utsdefs.h"

//////////////////////////////////////////////////////////////////////////////
/*
  It is recommended that you use primarily the mechanisms defined in
  UnitTestDefs.h to define test case and test suite objects.  Memory
  management for the objects defined here and their name strings is
  very simple in order to simplify program initialization, but is
  therefore also somewhat fragile. The definition macros take care of
  these concerns.

  Test objects taking name string arguments in their constructors will
  keep a copy of the pointer.
*/

namespace uts
{

  class Test;            // Base class for named objects in the test hierarchy
  class TestCase;        // Leaf objects: runnable test cases
  class TestSuite;       // Collection of Test objects
  class TestContext;     // Context information for test cases
  class TestVisitor;     // Base class for objects that can visit all nodes
                         // in a test hierarchy.
  class XTestFailure;    // Exception object indicating test case failure.
  class RootTestSuite;   // Hidden class for root suite.

  /*
    The test hierarchy follows a modified Visitor pattern which
    distinguishes between visiting leaf nodes (tests) and branch nodes
    (test suites). Here is the abstract interface for visitor objects.
  */
  class TestVisitor
  {
  public:
    UTS_EXPORT virtual ~TestVisitor();
    /*
      visitEnter() is called when a test suite is first
      encountered. The visitor should return true if it wishes to
      visit the contents of this suite, in which case each child (test
      suite or test case) is visited in alphabetical order.
    */
    UTS_EXPORT virtual bool visitEnter(TestSuite&) = 0;

    /*
      visitLeave() is called after all children of a test suite have
      been visited.  It is not called if visitEnter returned false for
      the suite.  If visitLeave() returns false, then the rest of the
      siblings of the test suite (if any) will be skipped. (The return
      value of visit() has a similar effect for test cases.)
    */
    UTS_EXPORT virtual bool visitLeave(TestSuite&) = 0;

    /*
      visit() is called once for each test case in a test suite that
      is being processed by a visitor.  If visit() returns false, then
      no further sibilings of this test (if any) will be
      processed. (The return value of visitLeave() has a similar
      effect for test suites.)
    */
    UTS_EXPORT virtual bool visit(TestCase&) = 0;
  };

  /*
    Test is the base class for all test objects. The public interface
    is very simple, providing access to a name, and allowing a test to
    accept a visitor object.

    Test supports inclusion in singly-linked chain of test objects.  Though
    this support exists in the private interface, clients should be aware that
    any derived test object can be included in a chain of other test object
    derivations of the same or different type.  It is the responsibility of the
    chain manager to define the behavior of chain traversal.
  */
  class Test
  {
  public:
    UTS_EXPORT virtual ~Test();
    const std::string& name() const {return m_name;}

    /*
      accept() implements a typical Visitor pattern, facilitating dual
      run-time dispatch of visitor methods on test objects. The return
      value from accept() is used to control tree traversal by
      visitors.  A return value of true from accept() indicates that
      processing of this test's siblings should continue.
    */
    UTS_EXPORT virtual bool accept(TestVisitor&) = 0;

  protected:
    UTS_EXPORT Test(const std::string& name, TestSuite& parent);
  private:
    std::string m_name;

    friend class TestSuite;
    Test(); // Used only by root test suite
    Test* m_next; // See comments in .cpp file.
  };

  /*
    The TestContext interface provides various pieces of important
    context information and services to test cases. The default
    implementation is very simple. It is intended to be used as a base
    class when more complex test environments are needed.
  */
  class TestContext
  {
  public:
    UTS_EXPORT TestContext(std::ostream* logStream = &std::cerr);
    UTS_EXPORT virtual ~TestContext();

    /*
      Tests should send any interesting output to the stream returned
      by logStream().  Remember that when successful, tests should
      produce minimal or no output so that developers aren't inundated
      with clutter. Pass/Fail indications should be generated by test
      visitor objects that run the tests, rather than by the tests
      themselves.
    */
    UTS_EXPORT virtual std::ostream& logStream() const;

    /*
      shouldStop returns true if testing should be halted. This can be
      used by test visitors to abort recursion, and should be used by
      test cases to allow lengthy iterations to be aborted. The
      default implementation always returns false.
    */
    UTS_EXPORT virtual bool shouldStop() const;

    // If stopTests is called , all subsequent calls to shouldStop will return true.
    UTS_EXPORT virtual void stopTests();

  private:
    std::ostream* m_logStream;
    bool m_continueTests;
  };

  /*
    A test case represents an actual test, a leaf node in the test
    hierarchy.
  */
  class TestCase : public Test
  {
  public:
    UTS_EXPORT virtual bool accept(TestVisitor&);  // returns v.visit(*this)

    /*
      run() executes the test. Failure should be indicated by throwing
      an XTestFailure exception. Normal return indicates success.
    */
    UTS_EXPORT virtual void run(TestContext&) = 0;

  protected:
    UTS_EXPORT TestCase (const std::string& name, TestSuite& parent);

  };

  /*
    A test suite is a composite test.
  */
  class TestSuite : public Test
  {
  public:
    UTS_EXPORT TestSuite(const std::string& name, TestSuite& parent);
    UTS_EXPORT ~TestSuite();

    UTS_EXPORT virtual bool accept(TestVisitor&);

  private:
    std::vector<Test*> m_children;

    friend class RootTestSuite;
    TestSuite();  // Used only by root test suite

    friend class Test;
    Test*              m_testChain; // See comments in .cpp file.
    void initChildList();
  };

  /*
    XTestFailure is the exception object used to indicate test
    failure.
  */
  class XTestFailure : public std::exception
  {
  public:
    UTS_EXPORT XTestFailure(const std::string& desc);
    UTS_EXPORT XTestFailure(const std::string& desc, const std::string& file, long line);
    UTS_EXPORT virtual ~XTestFailure() throw();
    UTS_EXPORT virtual const char* what() const throw();

    std::string m_desc;
    std::string m_file;
    long        m_line;
  };
}  // end namespace

#endif


